#!/usr/bin/env python3

"""Plot generator.

Given a csv data file, generated by jcdp_batch, generate the
corresponding
"""

from __future__ import annotations

import sys
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import argparse

description = """\
Genrate boxplots for the data files written by jcdp_batch."""

help = """\
----------------------------------------------------------------------
Example uses:

  generate_plots.py results3.csv
    Shows the boxplots in a new window.

  generate_plots.py results3.csv foo.png
    Creates an image file and shows the plots afterwards.

  generate_plots.py results3.csv foo.pgf
    Creates pgfplots to be included in LaTeX.
"""


# -------------------------------------------------------------------- #
def main(input_file: str, output_file: str | None) -> int:
    """Run the plot generator."""

    # Read the data into a DataFrame
    df = pd.read_csv(input_file)

    # Determine the number of machines
    m = max(int(col.split("/")[1]) for col in df.columns if "BnB_BnB" in col)

    # Prepare results for boxplot
    ratios = []
    threads = []

    for t in range(1, m + 1):
        finished_col = f"BnB_BnB/{t}/finished"
        bnb_col = f"BnB_BnB/{t}"
        dp_col = f"DP/{t}"

        # Filter rows where BNB/N is finished (true)
        filtered_df = df[df[finished_col] == 1]

        # Calculate BNB/Dp ratios for valid entries and add to lists
        valid_ratios = filtered_df[bnb_col].astype(float) / filtered_df[
            dp_col
        ].astype(float)

        if not valid_ratios.empty:
            ratios.extend(valid_ratios.dropna().tolist())
            threads.extend([f"{t}"] * len(valid_ratios.dropna()))

    # Create a DataFrame for plotting with seaborn
    plot_data = pd.DataFrame({"Ratio": ratios, "Threads": threads})

    # Print minimum, average and percentage of optimal schedules
    summary = (
        plot_data.groupby("Threads")["Ratio"]
        .agg(
            min_ratio="min",
            mean_ratio="mean",
            count="count",
            count_100=lambda x: (x == 1).sum(),
        )
        .reset_index()
    )
    summary["perc_100"] = summary["count_100"] / summary["count"] * 100
    for _, row in summary.iterrows():
        print(
            f"Threads {row['Threads']}: min = {row['min_ratio']:.3f}, "
            f"average = {row['mean_ratio']:.3f}, "
            f"percentage of optimal schedules = {row['perc_100']:.1f}%"
        )

    # Plotting using seaborn
    plt.rcParams.update(
        {
            "font.size": 10,
            "text.usetex": True,
            "font.family": "serif",
            "text.latex.preamble": r"\usepackage{lmodern}",
            "axes.titlesize": 10,
        }
    )
    plt.figure(figsize=(3.5 * 0.98, 2.04))
    plt.ylim(0.65, 1.05)
    plt.axhline(y=1, color="gray", linestyle="--")

    sns.boxplot(
        x="Threads",
        y="Ratio",
        data=plot_data,
        whis=[2, 98],
        width=0.5,
        boxprops={"facecolor": (0.3, 0.5, 0.7, 0.5)},
        flierprops={"marker": "x"},
        medianprops={"color": "orange", "linewidth": 1.5},
    )

    plt.xlabel("Machines ($m$)")
    plt.ylabel("")
    plt.title(f"$\\mathcal{{C}}^{{(m)}}$ for chains of length $q={m}$")

    plt.tight_layout()
    if output_file:
        plt.savefig(output_file)
    else:
        plt.show()

    return 0


# -------------------------------------------------------------------- #

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=description,
        epilog=help,
    )
    parser.add_argument(
        "input_file",
        type=str,
        help="Path to the CSV file.",
    )
    parser.add_argument(
        "output_file",
        nargs="?",
        default=None,
        help="Path to save the output file (optional).",
    )
    opts = parser.parse_args()

    sys.exit(main(opts.input_file, opts.output_file))
